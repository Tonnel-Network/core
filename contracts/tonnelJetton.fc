#include "imports/merkleTreeJetton.fc";
#include "jetton/imports/jetton-utils.fc";
#include "jetton/imports/op-codes.fc";

const SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE = 64;
const ONE_TON = 1000000000;


() send_jetton(slice recepient, int amount, slice JETTON_MASTER_ADDRESS, cell JETTON_BYTE_CODE) impure inline {
    if (amount == 0) {
        return ();
    }
    slice jetton_wallet = calculate_user_jetton_wallet_address(my_address(), JETTON_MASTER_ADDRESS, JETTON_BYTE_CODE);

    var msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
            .store_slice(jetton_wallet)
            .store_coins(const::tx_fee_send_jetton)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
            .store_maybe_ref(
            begin_cell()
                .store_uint(op::transfer(), 32)
                .store_uint(0, 64)
                .store_coins(amount)
                .store_slice(recepient)
                .store_slice(recepient)
                .store_uint(0, 1)
                .store_coins(1)
                .store_uint(0, 1)
                .end_cell()
            );
    send_raw_message(msg.end_cell(), 1); ;; paying fees, revert on errors

}


() mint_tonnel(slice recepient, int amount, slice JETTON_MASTER_ADDRESS) impure inline {
    if (amount == 0) {
        return ();
    }
    var msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
            .store_slice(JETTON_MASTER_ADDRESS)
            .store_coins(const::tx_fee_send_jetton)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::mint(), 32)
            .store_uint(0, 64)
            .store_slice(recepient)
            .store_coins(20000000)
            .store_ref(
                    begin_cell().store_uint(op::internal_transfer(), 32)
                            .store_uint(0, 64)
                            .store_coins(amount)
                            .store_slice(JETTON_MASTER_ADDRESS)
                            .store_slice(recepient)
                            .store_coins(1)
                            .store_uint(0, 1)
                            .end_cell()
            );

    send_raw_message(msg.end_cell(), 2); ;; paying fees, don't revert on errors

}

() send_ton(slice recepient, int amount, int mode) impure inline {

    var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(recepient)
            .store_grams(amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell();
    send_raw_message(msg, mode);

}

() emit_log_simple (int event_id, slice data) impure inline {
    var msg = begin_cell()
            .store_uint (12, 4) ;; ext_out_msg_info$11 src:MsgAddressInt ()
            .store_uint (1, 2)
            .store_uint (256, 9)
            .store_uint(event_id, 256)
            .store_uint(0, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either
            .store_slice(data)
            .end_cell();
    send_raw_message(msg, 0);
}

(int) check_proof_for_insert(int old_root, int new_root, int commitment, int pathIndices, slice insert_proof) impure inline {

    slice alf1 =  begin_cell().store_uint(182000286537471, 48).store_uint(188678401565571, 48).store_uint(187245209450396, 48).store_uint(127518005434324, 48).store_uint(144397100865470, 48).store_uint(258741821310885, 48).store_uint(125665759774218, 48).store_uint(36382829990144, 48).end_cell().begin_parse();
    slice IC0 =  begin_cell().store_uint(149463881306625, 48).store_uint(144872300902732, 48).store_uint(174187054867017, 48).store_uint(116683277427982, 48).store_uint(265686967952922, 48).store_uint(252921879845267, 48).store_uint(114778485693866, 48).store_uint(5303972209837, 48).end_cell().begin_parse();
    slice IC1 =  begin_cell().store_uint(163889391969450, 48).store_uint(246380033874386, 48).store_uint(73095240576401, 48).store_uint(93872595764167, 48).store_uint(209061551175750, 48).store_uint(145133340025488, 48).store_uint(118965754737971, 48).store_uint(114963008012871, 48).end_cell().begin_parse();
    slice IC2 =  begin_cell().store_uint(154611330325417, 48).store_uint(56883882533380, 48).store_uint(256864073646890, 48).store_uint(110223718526805, 48).store_uint(41488761585151, 48).store_uint(66949550052602, 48).store_uint(59725992543201, 48).store_uint(60822399158111, 48).end_cell().begin_parse();
    slice IC3 =  begin_cell().store_uint(204323902231497, 48).store_uint(146515902261225, 48).store_uint(223686418609716, 48).store_uint(63159927913005, 48).store_uint(266511227424255, 48).store_uint(139647823215357, 48).store_uint(243275058806357, 48).store_uint(113688717611142, 48).end_cell().begin_parse();
    slice IC4 =  begin_cell().store_uint(183046732570304, 48).store_uint(73751093200306, 48).store_uint(222619922391300, 48).store_uint(264954189415027, 48).store_uint(63818347814842, 48).store_uint(185189879229344, 48).store_uint(215937361595168, 48).store_uint(212335368650295, 48).end_cell().begin_parse();
    slice beta2 =  begin_cell().store_uint(45268298785829999156800790826, 96).store_uint(49616257531946340397706624184, 96).store_uint(21860288103068343353898458482, 96).store_uint(44130212597109342573800170705, 96).store_uint(4047260717587677040649332350, 96).store_uint(38438004468883114874440114862, 96).store_uint(37382830912273952379501564462, 96).store_uint(68660724947650442889836600213, 96).end_cell().begin_parse();
    slice gamma2 =  begin_cell().store_uint(45765300665918301128790692768, 96).store_uint(42137484379184671317244818970, 96).store_uint(56280794141317933024253112594, 96).store_uint(6059577009407902906031811454, 96).store_uint(709198854518927808499549479, 96).store_uint(14165060894806320894179293954, 96).store_uint(55805278558791767872231965478, 96).store_uint(52000413785700509085167893944, 96).end_cell().begin_parse();
    slice delta2 =  begin_cell().store_uint(57404885677640579730243374799, 96).store_uint(74640312393593044018703206431, 96).store_uint(72169551985828096175287641873, 96).store_uint(73191377323043092450051400364, 96).store_uint(2166075833178725585951546652, 96).store_uint(27864811610718394234613231021, 96).store_uint(5303551526686084678103393224, 96).store_uint(16202961803211306031003898654, 96).end_cell().begin_parse();

    cell A_cell = insert_proof~load_ref();
    cell B_cell = insert_proof~load_ref();
    cell C_cell = insert_proof~load_ref();
    slice A = A_cell.begin_parse();
    slice B = B_cell.begin_parse();
    slice C = C_cell.begin_parse();
    slice vk_x = IC0;

    vk_x = bls_g1_add(vk_x, bls_g1_mul(IC1, old_root));
    vk_x = bls_g1_add(vk_x, bls_g1_mul(IC2, new_root));
    vk_x = bls_g1_add(vk_x, bls_g1_mul(IC3, commitment));
    vk_x = bls_g1_add(vk_x, bls_g1_mul(IC4, pathIndices));

    slice neg_a = bls_g1_negate(A);

    int success = bls_pairing_check(neg_a,
        B,
        alf1,
        beta2,
        vk_x,
        gamma2,
        C,
        delta2,
        4);
    ifnot (success) {
        return 0;
    }
    return 1;

}

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    (cell merkle, cell fee_info, cell nullifiers, cell jetton_info) = load_data(); ;; here we populate the storage variables

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    (slice fee_recepient, slice tonnel_jetton_master_address, int fee_percent, int tonnel_mint_amount_deposit, int tonnel_mint_amount_relayer, int fee_amount_total, int deposit_fee) = unpack_fee_info(fee_info);
    if (op == op::transfer_notification()) {
        ;; should check if jetton is valid
        int send_amount = in_msg_body~load_coins(); ;; Jettons send

        (slice jetton_master_address, cell JETTON_BYTECODE, cell stucks) = unpack_jetton_info(jetton_info);
        int fee_amount = POOL_SIZE * fee_percent / 1000;
        throw_unless(error::jetton_sender, equal_slices(sender_address, calculate_user_jetton_wallet_address(my_address(), jetton_master_address, JETTON_BYTECODE)));
        slice origin_sender = in_msg_body~load_msg_addr(); ;; transfer origin address

        if(msg_value < deposit_fee + const::tx_fee_send_jetton) {
            if (msg_value < const::tx_fee_send_jetton) {
                send_jetton(fee_recepient, send_amount, jetton_master_address, JETTON_BYTECODE);
                return ();
            }
            send_jetton(origin_sender, send_amount, jetton_master_address, JETTON_BYTECODE);
            return ();
        }

        if (send_amount != POOL_SIZE + fee_amount) {
            send_jetton(origin_sender, send_amount, jetton_master_address, JETTON_BYTECODE);
            return ();
        }

        cell commitment = in_msg_body~load_ref();
        slice commitment_slice = commitment.begin_parse();
        int commitment_value = commitment_slice~load_uint(256);
        int new_root = commitment_slice~load_uint(256);
        int given_old_root = commitment_slice~load_uint(256);
        cell insert_proof = commitment_slice~load_ref();
        slice insert_proof_slice = insert_proof.begin_parse();

        (int old_root, int last_index) = get_last_root_handler(merkle);
        throw_unless(error::verify_failed_input, commitment_value < FIELD_SIZE);
        throw_unless(error::verify_failed_input, new_root < FIELD_SIZE);

        int check = 0;
        if (given_old_root == old_root){
            check = check_proof_for_insert(old_root, new_root, commitment_value, last_index, insert_proof_slice);
        }
        if (check == 0) {
            stucks~udict_set(256, commitment_value, begin_cell().store_uint(commitment_value, 256).end_cell().begin_parse());
        } else {
            (int index, merkle) = insert(new_root,  merkle);
            emit_log_simple(op::deposit, begin_cell().store_uint(0 ,8).store_uint(commitment_value, 256).store_uint(index, 32).end_cell().begin_parse());
        }
        mint_tonnel(origin_sender, tonnel_mint_amount_deposit * ONE_TON, tonnel_jetton_master_address);


        save_data(merkle,
            pack_fee_info(fee_recepient, tonnel_jetton_master_address, fee_percent, tonnel_mint_amount_deposit, tonnel_mint_amount_relayer, fee_amount_total + fee_amount, deposit_fee),
            nullifiers,
            pack_jetton_info(jetton_master_address, JETTON_BYTECODE, stucks)
        );

        return ();
    }
    if (op == op::withdraw) {
        throw_unless(error::fund, msg_value > deposit_fee + 3 * const::tx_fee_send_jetton);

        ;;
        ;;
        ;; Proof inputs
        ;;
        ;;
        cell withdraw_info = in_msg_body~load_ref();
        slice withdraw_info_slice1 = withdraw_info.begin_parse();
        int root = withdraw_info_slice1~load_uint(256);
        int nullifier_hash = withdraw_info_slice1~load_uint(256);
        throw_unless(error::verify_failed_double_spend, is_unknown_nullifier(nullifier_hash, nullifiers));

        int fee_coef = withdraw_info_slice1~load_uint(10);
        cell addresses = withdraw_info_slice1~load_ref();
        slice addresses_slice = addresses.begin_parse();
        slice recipient = addresses_slice~load_msg_addr();
        throw_unless(error::verify_failed_input, root < FIELD_SIZE);
        throw_unless(error::verify_failed_input, nullifier_hash < FIELD_SIZE);
        throw_unless(error::verify_failed_fee, fee_coef < 1000);
        throw_unless(error::verify_failed_root, is_known_root(root));

        ;;
        ;;
        ;; Verifying Key constants
        ;;
        ;;


        slice alf1 =  begin_cell().store_uint(182000286537471, 48).store_uint(188678401565571, 48).store_uint(187245209450396, 48).store_uint(127518005434324, 48).store_uint(144397100865470, 48).store_uint(258741821310885, 48).store_uint(125665759774218, 48).store_uint(36382829990144, 48).end_cell().begin_parse();
        slice IC0 =  begin_cell().store_uint(198693471336772, 48).store_uint(15156426526669, 48).store_uint(21195839689806, 48).store_uint(134982884807240, 48).store_uint(98831944029365, 48).store_uint(259765280790088, 48).store_uint(226730109320416, 48).store_uint(68580818820928, 48).end_cell().begin_parse();
        slice IC1 =  begin_cell().store_uint(176967888897437, 48).store_uint(52716870066022, 48).store_uint(266882219203136, 48).store_uint(188956541049375, 48).store_uint(9638093056127, 48).store_uint(67879553530711, 48).store_uint(230356572703382, 48).store_uint(141548705617042, 48).end_cell().begin_parse();
        slice IC2 =  begin_cell().store_uint(185395607204924, 48).store_uint(103443686280834, 48).store_uint(16299229901343, 48).store_uint(112743106922236, 48).store_uint(67855685651818, 48).store_uint(19837995827628, 48).store_uint(5441989873390, 48).store_uint(68958062110528, 48).end_cell().begin_parse();
        slice IC3 =  begin_cell().store_uint(191936250497323, 48).store_uint(102852184355624, 48).store_uint(24212641576709, 48).store_uint(49960405572007, 48).store_uint(18362271019258, 48).store_uint(136287956340028, 48).store_uint(1904901475255, 48).store_uint(217912711665299, 48).end_cell().begin_parse();
        slice IC4 =  begin_cell().store_uint(147302141626805, 48).store_uint(120430951176259, 48).store_uint(71432139964580, 48).store_uint(205694061489863, 48).store_uint(151837152275069, 48).store_uint(13848984095571, 48).store_uint(278746640718118, 48).store_uint(253311207974946, 48).end_cell().begin_parse();
        slice beta2 =  begin_cell().store_uint(45268298785829999156800790826, 96).store_uint(49616257531946340397706624184, 96).store_uint(21860288103068343353898458482, 96).store_uint(44130212597109342573800170705, 96).store_uint(4047260717587677040649332350, 96).store_uint(38438004468883114874440114862, 96).store_uint(37382830912273952379501564462, 96).store_uint(68660724947650442889836600213, 96).end_cell().begin_parse();
        slice gamma2 =  begin_cell().store_uint(45765300665918301128790692768, 96).store_uint(42137484379184671317244818970, 96).store_uint(56280794141317933024253112594, 96).store_uint(6059577009407902906031811454, 96).store_uint(709198854518927808499549479, 96).store_uint(14165060894806320894179293954, 96).store_uint(55805278558791767872231965478, 96).store_uint(52000413785700509085167893944, 96).end_cell().begin_parse();
        slice delta2 =  begin_cell().store_uint(55611436019896542363365837820, 96).store_uint(36626239938280781222883835257, 96).store_uint(52040279991528111570885655812, 96).store_uint(2749671938796122801512470023, 96).store_uint(5914597108141076486454435704, 96).store_uint(13817988269852185537550968540, 96).store_uint(77612211829949484497625105164, 96).store_uint(61055469537419651796629832676, 96).end_cell().begin_parse();



        cell A_cell = withdraw_info_slice1~load_ref();
        cell B_cell = withdraw_info_slice1~load_ref();
        cell C_cell = withdraw_info_slice1~load_ref();
        slice A = A_cell.begin_parse();
        slice B = B_cell.begin_parse();
        slice C = C_cell.begin_parse();
        slice vk_x = IC0;


        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC1, root));
        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC2, nullifier_hash));
        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC3, recipient.preload_uint(256)));
        vk_x = bls_g1_add(vk_x, bls_g1_mul(IC4, fee_coef));

        slice neg_a = bls_g1_negate(A);
        int success = bls_pairing_check(neg_a,
                B,
                alf1,
                beta2,
                vk_x,
                gamma2,
                C,
                delta2,
                4);
        ifnot (success) {
            throw(error::verify_failed);
        }

        nullifiers~udict_set(256, nullifier_hash, begin_cell().end_cell().begin_parse());
        int fee_amount = fee_coef * POOL_SIZE / 1000;

        slice jetton_info_slice = jetton_info.begin_parse();
        slice jetton_master_address = jetton_info_slice~load_msg_addr();
        cell JETTON_BYTECODE = jetton_info_slice~load_ref();

        send_jetton(recipient, POOL_SIZE - fee_amount, jetton_master_address, JETTON_BYTECODE);
        send_jetton(sender_address, fee_amount, jetton_master_address, JETTON_BYTECODE);
        mint_tonnel(sender_address, tonnel_mint_amount_relayer * ONE_TON, tonnel_jetton_master_address);

        save_data(merkle,
                fee_info
            , nullifiers, jetton_info);
        emit_log_simple(op::withdraw, begin_cell().store_uint(1 ,8).store_uint(nullifier_hash, 256).store_slice(recipient).store_uint(fee_coef, 32).end_cell().begin_parse());

        return ();


    }

    if (op == op::remove_stuck_min) {
        (slice jetton_master_address, cell JETTON_BYTECODE, cell stucks) = unpack_jetton_info(jetton_info);

        (stucks, _, slice val, int flag) = stucks.udict_delete_get_min(256);
        throw_unless(error::empty_stuck, flag);
        int commitment_value_stuck = val~load_uint(256);
        cell commitment = in_msg_body~load_ref();
        slice commitment_slice = commitment.begin_parse();
        int commitment_value = commitment_slice~load_uint(256);
        int new_root = commitment_slice~load_uint(256);
        int given_old_root = commitment_slice~load_uint(256);
        cell insert_proof = commitment_slice~load_ref();
        slice insert_proof_slice = insert_proof.begin_parse();
        (int old_root, int last_index) = get_last_root_handler(merkle);
        throw_unless(error::verify_failed_input, commitment_value_stuck == commitment_value);
        throw_unless(error::verify_failed_input, commitment_value < FIELD_SIZE);
        throw_unless(error::verify_failed_input, new_root < FIELD_SIZE);
        int check = 0;
        if (given_old_root == old_root){
            check = check_proof_for_insert(old_root, new_root, commitment_value, last_index, insert_proof_slice);
        }

        throw_unless(error::verify_failed_input, check == 1);
        (int index, merkle) = insert(new_root,  merkle);

        emit_log_simple(op::deposit, begin_cell().store_uint(0 ,8).store_uint(commitment_value, 256).store_uint(index, 32).end_cell().begin_parse());
        save_data(merkle,
            fee_info,
            nullifiers,
            pack_jetton_info(jetton_master_address, JETTON_BYTECODE, stucks)
        );
        send_ton(sender_address, 0, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);

        return ();


    }

    throw_unless(401, equal_slices(sender_address, fee_recepient));
    if (op == op::change_config) {
        throw_unless(error::access_denied, equal_slices(sender_address, fee_recepient));
        slice fee_recepient_new = in_msg_body~load_msg_addr();
        int new_fee_percent = in_msg_body~load_uint(16);
        int new_tonnel_mint_amount_deposit = in_msg_body~load_uint(32);
        int new_tonnel_mint_amount_relayer = in_msg_body~load_uint(32);
        int deposit_fee_new = in_msg_body~load_coins();
        save_data(merkle,
                pack_fee_info(fee_recepient_new, tonnel_jetton_master_address, new_fee_percent, new_tonnel_mint_amount_deposit, new_tonnel_mint_amount_relayer, fee_amount_total, deposit_fee_new),
                nullifiers,
                jetton_info);
        return ();

    }
    if (op == op::claim_fee) {
        (slice jetton_master_address, cell JETTON_BYTECODE, _) = unpack_jetton_info(jetton_info);

        send_jetton(fee_recepient, fee_amount_total, jetton_master_address, JETTON_BYTECODE);
        fee_amount_total = 0;
        save_data(merkle,
                pack_fee_info(fee_recepient, tonnel_jetton_master_address, fee_percent, tonnel_mint_amount_deposit, tonnel_mint_amount_relayer, fee_amount_total, deposit_fee),
                nullifiers,
                jetton_info);
        return ();

    }
    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}



(int) check_verify(slice in_msg_body) method_id {
    in_msg_body~load_uint(32 + 64);
    (_, _, cell nullifiers, _) = load_data(); ;; here we populate the storage variables

    slice alf1 =  begin_cell().store_uint(182000286537471, 48).store_uint(188678401565571, 48).store_uint(187245209450396, 48).store_uint(127518005434324, 48).store_uint(144397100865470, 48).store_uint(258741821310885, 48).store_uint(125665759774218, 48).store_uint(36382829990144, 48).end_cell().begin_parse();
    slice IC0 =  begin_cell().store_uint(198693471336772, 48).store_uint(15156426526669, 48).store_uint(21195839689806, 48).store_uint(134982884807240, 48).store_uint(98831944029365, 48).store_uint(259765280790088, 48).store_uint(226730109320416, 48).store_uint(68580818820928, 48).end_cell().begin_parse();
    slice IC1 =  begin_cell().store_uint(176967888897437, 48).store_uint(52716870066022, 48).store_uint(266882219203136, 48).store_uint(188956541049375, 48).store_uint(9638093056127, 48).store_uint(67879553530711, 48).store_uint(230356572703382, 48).store_uint(141548705617042, 48).end_cell().begin_parse();
    slice IC2 =  begin_cell().store_uint(185395607204924, 48).store_uint(103443686280834, 48).store_uint(16299229901343, 48).store_uint(112743106922236, 48).store_uint(67855685651818, 48).store_uint(19837995827628, 48).store_uint(5441989873390, 48).store_uint(68958062110528, 48).end_cell().begin_parse();
    slice IC3 =  begin_cell().store_uint(191936250497323, 48).store_uint(102852184355624, 48).store_uint(24212641576709, 48).store_uint(49960405572007, 48).store_uint(18362271019258, 48).store_uint(136287956340028, 48).store_uint(1904901475255, 48).store_uint(217912711665299, 48).end_cell().begin_parse();
    slice IC4 =  begin_cell().store_uint(147302141626805, 48).store_uint(120430951176259, 48).store_uint(71432139964580, 48).store_uint(205694061489863, 48).store_uint(151837152275069, 48).store_uint(13848984095571, 48).store_uint(278746640718118, 48).store_uint(253311207974946, 48).end_cell().begin_parse();
    slice beta2 =  begin_cell().store_uint(45268298785829999156800790826, 96).store_uint(49616257531946340397706624184, 96).store_uint(21860288103068343353898458482, 96).store_uint(44130212597109342573800170705, 96).store_uint(4047260717587677040649332350, 96).store_uint(38438004468883114874440114862, 96).store_uint(37382830912273952379501564462, 96).store_uint(68660724947650442889836600213, 96).end_cell().begin_parse();
    slice gamma2 =  begin_cell().store_uint(45765300665918301128790692768, 96).store_uint(42137484379184671317244818970, 96).store_uint(56280794141317933024253112594, 96).store_uint(6059577009407902906031811454, 96).store_uint(709198854518927808499549479, 96).store_uint(14165060894806320894179293954, 96).store_uint(55805278558791767872231965478, 96).store_uint(52000413785700509085167893944, 96).end_cell().begin_parse();
    slice delta2 =  begin_cell().store_uint(55611436019896542363365837820, 96).store_uint(36626239938280781222883835257, 96).store_uint(52040279991528111570885655812, 96).store_uint(2749671938796122801512470023, 96).store_uint(5914597108141076486454435704, 96).store_uint(13817988269852185537550968540, 96).store_uint(77612211829949484497625105164, 96).store_uint(61055469537419651796629832676, 96).end_cell().begin_parse();

    ;;
    ;;
    ;; Proof inputs
    ;;
    ;;
    cell withdraw_info = in_msg_body~load_ref();
    slice withdraw_info_slice1 = withdraw_info.begin_parse();
    int root = withdraw_info_slice1~load_uint(256);
    int nullifier_hash = withdraw_info_slice1~load_uint(256);
    int fee_coef = withdraw_info_slice1~load_uint(10);
    cell addresses = withdraw_info_slice1~load_ref();
    slice addresses_slice = addresses.begin_parse();
    slice recipient = addresses_slice~load_msg_addr();

    cell A_cell = withdraw_info_slice1~load_ref();
    cell B_cell = withdraw_info_slice1~load_ref();
    cell C_cell = withdraw_info_slice1~load_ref();
    slice A = A_cell.begin_parse();
    slice B = B_cell.begin_parse();
    slice C = C_cell.begin_parse();
    slice vk_x = IC0;
    throw_unless(error::verify_failed_input, root < FIELD_SIZE);
    throw_unless(error::verify_failed_input, nullifier_hash < FIELD_SIZE);


    vk_x = bls_g1_add(vk_x, bls_g1_mul(IC1, root));
    vk_x = bls_g1_add(vk_x, bls_g1_mul(IC2, nullifier_hash));
    vk_x = bls_g1_add(vk_x, bls_g1_mul(IC3, recipient.preload_uint(256)));
    vk_x = bls_g1_add(vk_x, bls_g1_mul(IC4, fee_coef));
    throw_unless(error::verify_failed_fee, fee_coef < 1000);
    throw_unless(error::verify_failed_root, is_known_root(root));
    throw_unless(error::verify_failed_double_spend, is_unknown_nullifier(nullifier_hash, nullifiers));

    slice neg_a = bls_g1_negate(A);
    int success = bls_pairing_check(neg_a,
            B,
            alf1,
            beta2,
            vk_x,
            gamma2,
            C,
            delta2,
            4);
    ifnot (success) {
        return 0;
    }
    return 1;
}
